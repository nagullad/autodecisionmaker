name: Build and Deploy to ECS

on:
  workflow_dispatch:
    inputs:
      allow-listener-mutate:
        description: 'Set to true to allow the workflow to temporarily modify listener default actions to allow target group deletion'
        required: false
        default: 'false'

env:
  AWS_REGION: us-east-1
  APP_NAME: autodecisionmaker

jobs:
  build:
    runs-on: ubuntu-latest
    environment: prod

    outputs:
      image: ${{ steps.image.outputs.image }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repository exists
        run: |
          REPO_NAME=${{ env.APP_NAME }}
          echo "Checking if ECR repository exists: $REPO_NAME"
          aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ env.AWS_REGION }} || aws ecr create-repository --repository-name "$REPO_NAME" --region ${{ env.AWS_REGION }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Build Docker image
        id: image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: ${{ env.APP_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $REGISTRY/$REPOSITORY:latest
          echo "image=$REGISTRY/$REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Push image to ECR
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: ${{ env.APP_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:latest

      - name: Upload image name as artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-uri
          path: ./image_uri.txt

  terraform-plan:
    needs: build
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Terraform Format Check
        working-directory: ./terraform
        run: |
          set -e
          if terraform fmt -check ; then
            echo "Terraform files are formatted."
          else
            echo "Terraform formatting issues detected. Showing diff..."
            terraform fmt -diff
            echo "\nPlease run 'terraform fmt' locally in the ./terraform directory and commit the changes to fix formatting."
            exit 1
          fi

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./terraform
        env:
          TF_VAR_container_image: ${{ needs.build.outputs.image }}
        run: terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: ./terraform/tfplan

  terraform-apply:
    needs: [build, terraform-plan]
    runs-on: ubuntu-latest
    environment: prod
    env:
      TF_VAR_container_image: ${{ needs.build.outputs.image }}
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: ./terraform/

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Import existing ECR repository if present
        working-directory: ./terraform
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e
          REPO_NAME=${{ env.APP_NAME }}
          echo "Checking for existing ECR repository: $REPO_NAME"
          if aws ecr describe-repositories --repository-names "$REPO_NAME" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "ECR repository '$REPO_NAME' exists."
            if ! terraform state list | grep -q '^aws_ecr_repository\.app$' ; then
              echo "Importing existing ECR repository into Terraform state..."
              # Ensure non-interactive import by providing required variables via env and disabling input
              terraform import -input=false aws_ecr_repository.app "$REPO_NAME"
            else
              echo "ECR repository already present in Terraform state."
            fi
          else
            echo "ECR repository does not exist; Terraform will create it during apply."
          fi

      - name: Import other existing AWS resources if present
        working-directory: ./terraform
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          APP_NAME: ${{ env.APP_NAME }}
        run: |
          set -e

          ALB_NAME="${APP_NAME}-alb"
          TG_NAME="${APP_NAME}-tg"
          LOG_GROUP="/ecs/${APP_NAME}"
          ROLE_EXECUTION="${APP_NAME}-ecs-task-execution-role"
          ROLE_TASK="${APP_NAME}-ecs-task-role"

          echo "Checking for ALB: $ALB_NAME"
          ALB_ARN=$(aws elbv2 describe-load-balancers --names "$ALB_NAME" --region "$AWS_REGION" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
          if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
            echo "ALB exists: $ALB_ARN"
            if ! terraform state list | grep -q '^aws_lb\.main$' ; then
              echo "Importing ALB into terraform state..."
              terraform import -input=false aws_lb.main "$ALB_ARN"
            else
              echo "ALB already in terraform state"
            fi
          else
            echo "ALB not found"
          fi

          echo "Checking for Target Group: $TG_NAME"
          TG_ARN=$(aws elbv2 describe-target-groups --names "$TG_NAME" --region "$AWS_REGION" --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || true)
          if [ -n "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
            echo "Target group exists: $TG_ARN"
            if ! terraform state list | grep -q '^aws_lb_target_group\.main$' ; then
              echo "Importing target group into terraform state..."
              terraform import -input=false aws_lb_target_group.main "$TG_ARN"
            else
              echo "Target group already in terraform state"
            fi

            # Import listeners for the ALB so Terraform knows about dependencies
            echo "Checking for listeners on ALB: $ALB_ARN"
            LISTENER_ARNS=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --region "$AWS_REGION" --query 'Listeners[].ListenerArn' --output text 2>/dev/null || true)
            if [ -n "$LISTENER_ARNS" ] && [ "$LISTENER_ARNS" != "None" ]; then
              for LISTENER_ARN in $LISTENER_ARNS; do
                echo "Found listener: $LISTENER_ARN"
                if ! terraform state list | grep -q '^aws_lb_listener\.main$' ; then
                  echo "Importing listener into terraform state..."
                  terraform import -input=false aws_lb_listener.main "$LISTENER_ARN"
                else
                  echo "Listener already in terraform state"
                fi

                # Check for rules referencing the target group and warn if present
                echo "Checking rules on listener $LISTENER_ARN for references to $TG_ARN"
                RULES=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --region "$AWS_REGION" --query 'Rules[].RuleArn' --output text 2>/dev/null || true)
                for R in $RULES; do
                  TARGET_ARNS=$(aws elbv2 describe-rules --rule-arns "$R" --region "$AWS_REGION" --query 'Rules[0].Actions[?TargetGroupArn!=null].TargetGroupArn' --output text 2>/dev/null || true)
                          if echo "$TARGET_ARNS" | grep -q "$TG_ARN" ; then
                    echo "Rule $R references target group $TG_ARN."
                    IS_DEFAULT=$(aws elbv2 describe-rules --rule-arns "$R" --region "$AWS_REGION" --query 'Rules[0].IsDefault' --output text 2>/dev/null || true)
                    if [ "$IS_DEFAULT" = "true" ]; then
                      echo "Rule $R is the default rule for its listener."

                      # If permitted, temporarily replace default action with a fixed-response to allow TG deletion
                      if [ "${{ github.event.inputs['allow-listener-mutate'] }}" = 'true' ] || [ "$ALLOW_LISTENER_MUTATE" = "true" ]; then
                        SANITIZED_ARN=$(echo "$LISTENER_ARN" | sed 's|[:/]|_|g')
                        mkdir -p ./terraform/listeners
                        echo "Saving original default actions for $LISTENER_ARN to ./terraform/listeners/${SANITIZED_ARN}.json"
                        aws elbv2 describe-listeners --listener-arns "$LISTENER_ARN" --region "$AWS_REGION" --query 'Listeners[0].DefaultActions' --output json > ./terraform/listeners/${SANITIZED_ARN}.json
                        echo "Replacing default action with fixed-response for listener $LISTENER_ARN"
                        aws elbv2 modify-listener --listener-arn "$LISTENER_ARN" --default-actions '[{"Type":"fixed-response","FixedResponseConfig":{"MessageBody":"temporarily-unavailable","StatusCode":"200","ContentType":"text/plain"}}]' --region "$AWS_REGION"
                        echo "$LISTENER_ARN" >> ./terraform/listeners/modified.txt
                      else
                        echo "Default rule blocks deletion. To allow automatic fix, re-run workflow with 'allow-listener-mutate=true' input or import/remove the rule manually."
                        exit 1
                      fi
                    else
                      # If rule isn't managed by terraform (no aws_lb_listener_rule.* in state) and is not default, delete it to allow TG deletion
                      if [ "$IS_DEFAULT" = "false" ] && ! terraform state list | grep -q '^aws_lb_listener_rule\.' ; then
                        echo "Rule $R appears unmanaged and not default; deleting it to allow target group deletion."
                        aws elbv2 delete-rule --rule-arn "$R" --region "$AWS_REGION" || true
                      else
                        echo "Rule $R may be managed by Terraform, is default, or ensure it is in state or config."
                      fi
                    fi
                  fi
                done

              done
            else
              echo "No listeners found"
            fi

          else
            echo "Target group not found"
          fi

          echo "Checking for CloudWatch Log Group: $LOG_GROUP"
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --region "$AWS_REGION" --query 'logGroups[?logGroupName==`'"$LOG_GROUP"'`].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP" ; then
            echo "Log group exists: $LOG_GROUP"
            if ! terraform state list | grep -q '^aws_cloudwatch_log_group\.ecs$' ; then
              echo "Importing CloudWatch log group into terraform state..."
              terraform import -input=false aws_cloudwatch_log_group.ecs "$LOG_GROUP"
            else
              echo "Log group already in terraform state"
            fi
          else
            echo "Log group not found"
          fi

          echo "Checking for IAM Role: $ROLE_EXECUTION"
          if aws iam get-role --role-name "$ROLE_EXECUTION" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "IAM role exists: $ROLE_EXECUTION"
            if ! terraform state list | grep -q '^aws_iam_role\.ecs_task_execution_role$' ; then
              echo "Importing IAM role execution into terraform state..."
              terraform import -input=false aws_iam_role.ecs_task_execution_role "$ROLE_EXECUTION"
            else
              echo "IAM role execution already in terraform state"
            fi
          else
            echo "IAM role execution not found"
          fi

          echo "Checking for IAM Role: $ROLE_TASK"
          if aws iam get-role --role-name "$ROLE_TASK" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "IAM role exists: $ROLE_TASK"
            if ! terraform state list | grep -q '^aws_iam_role\.ecs_task_role$' ; then
              echo "Importing IAM role task into terraform state..."
              terraform import -input=false aws_iam_role.ecs_task_role "$ROLE_TASK"
            else
              echo "IAM role task already in terraform state"
            fi
          else
            echo "IAM role task not found"
          fi

      - name: Recreate plan (after imports)
        working-directory: ./terraform
        run: |
          set -e
          echo "Recreating terraform plan after import to avoid stale plan..."
          terraform plan -out=tfplan -input=false

      - name: Wait for target group to be free
        working-directory: ./terraform
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          APP_NAME: ${{ env.APP_NAME }}
        run: |
          set -e
          TG_NAME="${APP_NAME}-tg"
          echo "Checking target group: $TG_NAME"
          TG_ARN=$(aws elbv2 describe-target-groups --names "$TG_NAME" --region "$AWS_REGION" --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || true)
          if [ -z "$TG_ARN" ] || [ "$TG_ARN" = "None" ]; then
            echo "No target group found; nothing to wait for"
          else
            echo "Found target group ARN: $TG_ARN"
            max=24
            i=0
            while [ $i -lt $max ]; do
              # find any rules referencing TG
              BLOCKING_RULES=""
              LISTENERS=$(aws elbv2 describe-listeners --load-balancer-arn $(aws elbv2 describe-load-balancers --names "${APP_NAME}-alb" --region "$AWS_REGION" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "") --region "$AWS_REGION" --query 'Listeners[].ListenerArn' --output text 2>/dev/null || true)
              for L in $LISTENERS; do
                RULES=$(aws elbv2 describe-rules --listener-arn "$L" --region "$AWS_REGION" --query 'Rules[].RuleArn' --output text 2>/dev/null || true)
                for R in $RULES; do
                  if aws elbv2 describe-rules --rule-arns "$R" --region "$AWS_REGION" --query 'Rules[0].Actions[?TargetGroupArn!=`null`].TargetGroupArn' --output text 2>/dev/null | grep -q "$TG_ARN" ; then
                    BLOCKING_RULES="$BLOCKING_RULES $R"
                  fi
                done
              done

              TARGETS=$(aws elbv2 describe-target-health --target-group-arn "$TG_ARN" --region "$AWS_REGION" --query 'TargetHealthDescriptions[].Target.Id' --output text 2>/dev/null || true)

              if [ -z "$BLOCKING_RULES" ] && [ -z "$TARGETS" ]; then
                echo "Target group is free."
                break
              fi

              if [ -n "$BLOCKING_RULES" ]; then
                echo "Blocking rules detected:$BLOCKING_RULES"
                if [ "${{ github.event.inputs['allow-listener-mutate'] }}" = 'true' ] || [ "$ALLOW_LISTENER_MUTATE" = "true" ]; then
                  for R in $BLOCKING_RULES; do
                    echo "Processing blocking rule $R"
                    IS_DEFAULT=$(aws elbv2 describe-rules --rule-arns "$R" --region "$AWS_REGION" --query 'Rules[0].IsDefault' --output text 2>/dev/null || true)
                    LISTENER_ARN=$(aws elbv2 describe-rules --rule-arns "$R" --region "$AWS_REGION" --query 'Rules[0].ListenerArn' --output text 2>/dev/null || true)
                    if [ "$IS_DEFAULT" = "true" ]; then
                      echo "Rule $R is a default rule for listener $LISTENER_ARN."
                      SANITIZED_ARN=$(echo "$LISTENER_ARN" | sed 's|[:/]|_|g')
                      mkdir -p ./terraform/listeners
                      if [ ! -f "./terraform/listeners/${SANITIZED_ARN}.json" ]; then
                        echo "Saving original default actions for $LISTENER_ARN to ./terraform/listeners/${SANITIZED_ARN}.json"
                        aws elbv2 describe-listeners --listener-arns "$LISTENER_ARN" --region "$AWS_REGION" --query 'Listeners[0].DefaultActions' --output json > ./terraform/listeners/${SANITIZED_ARN}.json || true
                        echo "$LISTENER_ARN" >> ./terraform/listeners/modified.txt
                      else
                        echo "Original actions already saved for $LISTENER_ARN"
                      fi
                      echo "Replacing default action with fixed-response for listener $LISTENER_ARN"
                      aws elbv2 modify-listener --listener-arn "$LISTENER_ARN" --default-actions '[{"Type":"fixed-response","FixedResponseConfig":{"MessageBody":"temporarily-unavailable","StatusCode":"200","ContentType":"text/plain"}}]' --region "$AWS_REGION" || true
                    else
                      if [ "$IS_DEFAULT" = "false" ]; then
                        echo "Rule $R is not default. Attempting to delete if unmanaged."
                        if ! terraform state list | grep -q '^aws_lb_listener_rule\.' ; then
                          echo "Deleting unmanaged rule $R"
                          aws elbv2 delete-rule --rule-arn "$R" --region "$AWS_REGION" || true
                        else
                          echo "Rule $R may be managed by Terraform; ensure it is in state or config."
                        fi
                      else
                        echo "Rule $R may be default or unknown; skipping deletion."
                      fi
                    fi
                  done
                else
                  echo "Blocking rules present and mutation not allowed. Aborting to avoid unsafe changes. Re-run with allow-listener-mutate=true or import the blocking rules into Terraform."
                  exit 1
                fi
              fi

              if [ -n "$TARGETS" ]; then
                echo "Deregistering targets: $TARGETS"
                for ID in $TARGETS; do
                  aws elbv2 deregister-targets --target-group-arn "$TG_ARN" --targets Id=$ID --region "$AWS_REGION" || true
                done
              fi

              sleep 5
              i=$((i+1))
            done

            if [ $i -ge $max ]; then
              echo "Timed out waiting for target group to be free."
              exit 1
            fi
          fi

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -input=false tfplan

      - name: Restore modified listeners (if any)
        working-directory: ./terraform
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e || true
          LIST_DIR=./terraform/listeners
          if [ -f "$LIST_DIR/modified.txt" ]; then
            echo "Restoring modified listeners..."
            while read -r L; do
              SANITIZED_ARN=$(echo "$L" | sed 's|[:/]|_|g')
              if [ -f "$LIST_DIR/${SANITIZED_ARN}.json" ]; then
                echo "Restoring default actions for $L from $LIST_DIR/${SANITIZED_ARN}.json"
                aws elbv2 modify-listener --listener-arn "$L" --default-actions file://$LIST_DIR/${SANITIZED_ARN}.json --region "$AWS_REGION" || true
                rm -f "$LIST_DIR/${SANITIZED_ARN}.json"
              else
                echo "Original actions file missing for $L"
              fi
            done < "$LIST_DIR/modified.txt"
            rm -f "$LIST_DIR/modified.txt"
          else
            echo "No modified listeners to restore."
          fi

      - name: Get ALB DNS
        working-directory: ./terraform
        run: |
          terraform output -raw alb_dns_name > ../alb_dns.txt
          cat ../alb_dns.txt

      - name: Upload ALB DNS
        uses: actions/upload-artifact@v4
        with:
          name: alb-dns
          path: ./alb_dns.txt

  update-ecs-service:
    needs: [build, terraform-apply]
    runs-on: ubuntu-latest
    environment: prod
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS Service
        run: |
          aws ecs update-service \
            --cluster ${{ env.APP_NAME }}-cluster \
            --service ${{ env.APP_NAME }}-service \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for service deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.APP_NAME }}-cluster \
            --services ${{ env.APP_NAME }}-service \
            --region ${{ env.AWS_REGION }}

      - name: Verify Deployment
        run: |
          aws ecs describe-services \
            --cluster ${{ env.APP_NAME }}-cluster \
            --services ${{ env.APP_NAME }}-service \
            --region ${{ env.AWS_REGION }}

  notify:
    needs: [build, update-ecs-service]
    runs-on: ubuntu-latest
    environment: prod
    if: always()
    steps:
      - name: Download ALB DNS
        if: needs.build.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: alb-dns

      - name: Deployment Summary
        run: |
          echo "?? Deployment Summary"
          echo "====================="
          echo "Application: ${{ env.APP_NAME }}"
          echo "Image: ${{ needs.build.outputs.image }}"
          echo "Region: ${{ env.AWS_REGION }}"
          if [ -f alb_dns.txt ]; then
            echo "Access URL: http://$(cat alb_dns.txt)"
          fi
